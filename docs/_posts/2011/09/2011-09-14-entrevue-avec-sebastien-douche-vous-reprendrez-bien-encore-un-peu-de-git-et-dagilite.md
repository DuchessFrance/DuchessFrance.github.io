---
layout: "post"
author: 
  - "acrepet"
title: "Entrevue avec Sébastien Douche : vous reprendrez bien encore un peu de Git et d’Agilité?"
date: "2011-09-14"
categories: 
  - "les-conferences"
tags: 
  - "agilite"
  - "dvcs"
  - "git"
  - "lyon-jug"
---

| Le 20 septembre prochain, le [Lyon JUG](http://www.lyonjug.org/) propose une session sur [Git](http://git-scm.com/), animée par [Sébastien Douche](http://twitter.com/sdouche). Il proposera également le lendemain, toujours à Lyon, un coding dojo pour vous fournir une initiation pratique à [Git](http://git-scm.com/)! |

[![@sdouche](/assets/2011/09/2011-09-14-entrevue-avec-sebastien-douche-vous-reprendrez-bien-encore-un-peu-de-git-et-dagilite/sebastienDouche-h114.jpg)](http://twitter.com/sdouche) Quand on demande à Sébastien de se présenter voici ce qu’il nous répond : “Je m’appelle Sébastien Douche, 36 ans, j’ai commencé à tater des ordis avec les jeux vidéos il y’a 30 ans au Japon. Je me suis mis à la programmation assez jeune (C et assembleur x86) sous MS-Dos (ah le compilateur Watcom). La découverte d’Internet en 95 a bouleversé mon existence de geek, avec Linux et les Logiciels Libres, ainsi que pas mal de langages comme Eiffel, D, Erlang, Ada, Objective C, Smalltalk, Forth, REBOL et tant d’autres. Mais mon profil est assez atypique car je me suis vite intéressé à d’autres domaines comme l’agilité, l’administration système, le coaching et enfin la gestion d’organisation car je ne comprenais pas pourquoi je me sentais aussi mal dans les entreprises où je travaillais. Depuis 4 ans, je peux mélanger toutes ces passions dans mon activité professionnelle chez un éditeur logiciel Français.”

Puisque Sébastien et le [Lyon JUG](http://www.lyonjug.org/) avaient envie de vous faire plaisir, vous avez le droit à cet interview mais également très bientôt à un nouvel opus du podcast [Cast-IT](http://www.cast-it.fr/), qui sortira peu après le 20 septembre (le temps du montage!). Si vous ne connaissez pas ce podcast émanant de la team du Lyon JUG, [Cast-IT](http://www.cast-it.fr/), allez vite écouter les premiers épisodes de ce nouveau podcast participatif sur l’écosystème Java, certes, mais ouvert également à des sujets comme l’Agilité ou d’autres langages. Ça tombe bien, même si Sébastien va nous parler de [Git](http://git-scm.com/) pour sa session au [Lyon JUG](http://www.lyonjug.org/), on voit dans sa présentation qu’il a bien d’autres centres d’intérêts : on va donc parler de Git bien sûr, mais aussi aborder avec lui d’autres de ses sujets de prédilection, notamment l’Agilité!

_Cet interview a été préparé conjointement par [Agnès CREPET](http://twitter.com/agnes_crepet) et [Cédric EXBRAYAT](http://twitter.com/cedric_exbrayat), deux membres de la team du [Lyon JUG](http://www.lyonjug.org/)._

**Agnès & Cédric: Tu proposes un talk sur [Git](http://git-scm.com/), un système de gestion de version décentralisé (DVCS). Étant depuis longtemps présent dans les communautés des logiciels libres, peux-tu nous dire en quoi les DVCS ont été bénéfiques pour ces communautés ?**

**Sébastien**: Les DVCS ont permis d’améliorer grandement la gestion de projet, raison pour laquelle beaucoup de projets Libres ont sauté le pas. Torvalds avait compris dès 2002 l’intérêt de [BitKeeper](http://www.bitkeeper.com/) (le 1er DVCS) et refusait catégoriquement d’utiliser CVS. Il faut dire qu’avec 10 ans d’expérience de management du plus gros projet Libre, il commençait à avoir de la bouteille. Dans un projet Libre, on passe beaucoup de temps à tester et à intégrer du code, et la souplesse offerte par l’outil de gestion de source est importante. Or, SVN impose de par sa conception un management restrictif, seules les personnes habilitées ont droit de commit, donc de travailler avec l’outil. Pire, chaque développeur ne peut pas choisir librement sa méthode de travail sans impacter les autres développeurs, voir la stabilité du projet. C’est pour cela qu’il faut bien souvent montrer patte blanche avant de réellement participer, alors que la facilité d’immersion dans un projet Libre est fondamentale pour sa réussite.

Dans ces conditions, le DVCS est un atout majeur en décorellant la façon de gérer le projet des envies ou besoins des développeurs. Chacun pouvant donc, à son niveau, définir sa méthode de travail. C’est ce que j’appelle _workflow organisationnel_ (le management de projet) et _workflow personnel_ (la méthode de travail du développeur). Voici un exemple avec le projet Python : le responsable projet demande un commit unique par fonctionnalité si je suis _core développeur_ ou un patch sur le bugtracker dans le cas contraire. Cette contrainte n’impose pas une quelconque façon de travailler sur ma machine, mais seulement ma relation avec le projet. Par une IHM bien pensée et des fonctionnalités intéressantes, des sites comme [GitHub](https://github.com/) ou [Bitbucket](https://bitbucket.org/) abaissent encore plus le coût de participation.

De plus les DVCS sont bien mieux pensées. [SVN](http://subversion.apache.org/) croule sous le poids des années. Il faut rappeler qu’il est sorti en 2001 comme une amélioration de CVS sorti en 1990, lui même étant une amélioration de RCS sorti en 1982, lui même un portage Unix de SCCS sorti en 1972 (ouf !). On a beaucoup appris en 30 ans. Je pense notamment au graphe des commits (que l’on appelle le DAG) des DVCS et son équivalent atrophié SVN, qui impose cette façon si peu efficace de gérer les branches. Tellement peu efficace qu’elles sont rarement utilisées, voir interdites.

**Agnès & Cédric: Naïvement, on peut facilement voir l’intérêt d’un DVCS pour des personnes travaillant en mode distant, mais au sein d’une entreprise, ce type d’outil a t’il vraiment des plus-values? Si oui lesquelles? En quoi une entreprise doit-elle être vigilante avant de passer à un outil comme [Git](http://git-scm.com/) ?**

**Sébastien**: Le terme distribué est trompeur, car on pense «déconnecté» ou «distant» alors qu’il faut lire «autonome». La possibilité de télétravailler chez soit ou dans le train n’est qu’une conséquence d’une architecture qui me permet avant tout de travailler localement, sans fil à la patte. Je suis autonome et je décide ce que je veux partager : le développeur devient un producteur de contenu. C’est la distinction des workflows de ma réponse précédente. En tant que responsable, la possibilité de définir le _workflow organisationnel_ est un atout majeur pour améliorer la qualité du projet. Et pour le développeur, un confort incomparable de disposer de sa méthode de travail. Pour rien au monde je ne reviendrais à SVN et pour tout dire je refuserais un poste si je devais travailler avec. Pour citer ma présentation DVCS au ParisJUG, le dernier slide dit «si vous devez apprendre une chose en 2010, ce n’est pas (je liste les technos Java à la mode) mais un DVCS». A part virer Windows, je ne crois pas avoir vu un gain de productivité aussi notable avec un simple changement d’outil. Et c’est le développeur, le coach, le responsable R&D et le directeur technique qui parlent ![:)](http://jduchess.org/duchess-france/wp-includes/images/smilies/icon_smile.gif) .

En tant que responsable R&D, j’ai vécu le changement SVN vers [Mercurial](http://mercurial.selenic.com/), puis [Git](http://git-scm.com/). Il y a deux difficultés :

1. bien comprendre les concepts des DVCS, et de [Git](http://git-scm.com/) en particulier qui est à l’opposé de SVN tant vous êtes libre de faire ce que vous voulez avec. C’est pour cela que ma conférence est avant tout structurée pour assimiler les concepts, et non les commandes comme je le vois malheureusement trop souvent.
2. il faut expliquer aux développeurs et aux responsables projets les différents workflows pour les aider à en adopter un. C’est le deuxième objectif de la conférence, mais l’avantage de l’atelier est ici évident car on peut pratiquer et en parler assez longuement.

Si je dois résumer, je dirais que l’on passe d’un mode de travail rudimentaire à une liberté totale. C’est banal à dire, mais la liberté est une chose merveilleuse et on se demande comment on a pu être aussi stupide de se laisser enfermer. Mais cette liberté exige discipline et responsabilisation. Et ne rêvez pas, vous ne deviendrez pas magiquement un meilleur développeur pour autant ![;)](http://jduchess.org/duchess-france/wp-includes/images/smilies/icon_wink.gif) .

**Agnès & Cédric: Utilises-tu un système de workflow avec [Git](http://git-scm.com/) ? As-tu des astuces pour simplifier la migration et l’adoption en entreprise ?**

**Sébastien**: On a toujours un workflow, même sans le savoir ![:)](http://jduchess.org/duchess-france/wp-includes/images/smilies/icon_smile.gif) . Voici mon workflow personnel pour chaque fonctionnalité que je dois coder :

- je commite énormément et de toutes petites modifications.
- j’utilise beaucoup de branches de travail (comme wip, backup, step1, step2) comme marqueur pour identifier chaque étape et y revenir si besoin.
- une fois le travail terminé, je pousse tout dans la branche principale de la fonctionnalité nouvellement créée et je la nettoie si cela est nécessaire : fusion et ré-ordonnancement des commits, décomposition d’un commit en plusieurs si j’ai mélangé plusieurs modifications sans lien entre elles et ré-écriture des messages de commit si besoin. J’appelle cela une branche «propre», un historique agréable à lire et facile à comprendre pour un relecteur, avec des commits «unitaires», c’est à dire cohérents et compréhensibles par eux-même.
- je pousse sur le serveur principal pour revue de code.
- quand la revue est validée, je _rebase_ avec la branche _master_ et je _merge_ en _non fast-forward_.
- je supprime toutes les branches locales ainsi que la branche sur le serveur.

Nous avons eu plusieurs workflows organisationnels dans le temps. Par exemple avec [Mercurial](http://mercurial.selenic.com/), j’étais l’intégrateur : les développeurs envoyaient un patch une fois la revue terminée et j’intégrais. C’est un workflow qu’utilisent beaucoup de projets Libres. Actuellement avec [Git](http://git-scm.com/), nous avons la branche _master_, la branche par fonctionnalité, une branche pour chaque étape de développement de cette fonctionnalité et enfin une branche de maintenance par version majeure. Mais nous n’avons pas de branche d’intégration générale (lisez [git-flow](http://nvie.com/posts/a-successful-git-branching-model/) si cela ne vous semble pas clair ou venez à une de mes conférences ![:)](http://jduchess.org/duchess-france/wp-includes/images/smilies/icon_smile.gif) ).

**Agnès & Cédric: Tu as essayé d’autres DVCS que [Git](http://git-scm.com/), tu dis être passé de [Mercurial](http://mercurial.selenic.com/) à [Git](http://git-scm.com/) par exemple. Qu’est-ce qui t’as poussé à changer de DVCS. As-tu des retours sur d’autres DVCS moins répandus comme [Veracity de SourceGear](http://veracity-scm.com) proposant un certain nombre de features en plus de [Git](http://git-scm.com/) ?**

**Sébastien**: J’ai utilisé [Mercurial (Hg)](http://mercurial.selenic.com/) deux années au taff et un peu joué avec [Monotone](http://www.monotone.ca/) et [Darcs](http://darcs.net/), deux DVCS de première génération. Faisant beaucoup de veille, je reste à l’affût de toute nouveauté, et j’ai quelques fonctionnalités en tête que j’aimerais bien voir dans [Git](http://git-scm.com/). Nous sommes passé de [Hg](http://mercurial.selenic.com/) à [Git](http://git-scm.com/) pour deux raisons : la curiosité intellectuelle, et parce que la gestion des branches dans [Hg](http://mercurial.selenic.com/) est assez simpliste, il faut cloner le dépôt quand on veut travailler temporairement sur une branche ce qui est loin d’être convivial (je crois que les développeurs de [Hg](http://mercurial.selenic.com/) travaillent là dessus). Notez qu’on aurait pu rester sur [Hg](http://mercurial.selenic.com/), mais je suis très heureux d’avoir basculé.

Pour [Veracity](http://veracity-scm.com), je suis circonspect. Un outil qui intègre DVCS, wiki, bugtracker et Burndown Chart donne l’impression d’un outil qui se veut certes accessible pour l’entreprise, mais bien trop intégré à mon goût. C’est l’opposé de ma philosophie qui vient d’Unix : un bon outil pour une tâche donnée. Je n’aime pas les outils intégrés, surtout si c’est une brique d’infrastructure. Il a fallu une semaine pour passer de [Hg](http://mercurial.selenic.com/) à [Git](http://git-scm.com/) et adapter nos outils, que se passe t’il si je veux quitter [Veracity](http://veracity-scm.com) ? Mais il est intéressant de noter que les nouveaux outils ([Veracity](http://veracity-scm.com), [Fossil](http://www.sqlite.org/debug1/doc/trunk/www/theory1.wiki)) sont des DVCS. Ceci dit, je mets \*tout\* dans un dépôt [Git](http://git-scm.com/): code, données, binaire, fichier de configuration, documents (vive le format texte comme le _rst_ ou le _markdown_), blog, site web et j’attends un bugtracker et un wiki digne de ce nom avec un _backend_ [Git](http://git-scm.com/). Il faut noter que [Git](http://git-scm.com/), [Mercurial](http://mercurial.selenic.com/) et [Bzr](http://bazaar.canonical.com/en/) partagent une conception assez proche et les migrations entre DVCS sont simples, et on trouve d’ailleurs des projets Libres en dépôt [Git](http://git-scm.com/) et [Hg](http://mercurial.selenic.com/).

La seule fonctionnalité intéressante que j’ai pu voir dans les DVCS récents est [l’autosync](http://www.sqlite.org/debug1/doc/trunk/www/concepts.wiki) de [Fossil](http://www.sqlite.org/debug1/doc/trunk/www/theory1.wiki), permettant de “simuler SVN”, utile pour ceux qui débarquent dans le monde du DVCS. Sinon j’apprécie la facilité du _cherry-picking_ de [Darcs](http://darcs.net/) et les tags locaux de [Hg](http://mercurial.selenic.com/). Mais pour moi l’avancée marquante sera un outil graphique de visualisation du graphe des commits puissant. Je suis certes un amoureux de [Git](http://git-scm.com/), mais je n’hésiterais pas à changer si je trouve un outil plus intéressant. Il est important de ne pas se scléroser mentalement.

**Agnès & Cédric: Tu viens d’écrire un article “L’Agile est mort” dans l’été, qui a engendré pas mal de discussions/commentaires… A la fin de l’article tu proposes de regarder d’autres méthodes ou outils : tu parles notamment de Kanban. Peux-tu nous dire ce que Kanban t’a apporté ces dernières années ?**

**Sébastien**: Pour être précis, j’ai dit que le modèle Agile, inventé pour vendre du service, doit mourir. Nous progressons régulièrement dans la compréhension de notre métier et il est ridicule de continuer à pratiquer un management de 2001 parce qu’il est «bankable». C’est une problématique de consultants, pas des gens qui produisent. Toyota, Google ou Apple ne font pas du Lean truc ou du Scrum machin, ils font ce qui est utile et bon pour eux. Il est illusoire de déléguer à des consultants le management de son projet ou de son organisation, c’est \*votre\* travail. C’est l’objet de mon prochain billet sur le management qui s’intitule “N’écoutez pas les consultants”, et j’avoue que cela me démange de taper sur quelques personnes connues (françaises et internationales) qui disent n’importe quoi pour vendre leurs sauces. La montée en puissance du Kanban est un bon exemple, ou l’on retrouve régulièrement des sessions qui expliquent comment faire du «Scrum + Kanban», ce qui est assez pitoyable et montre soit l’incompétence, soit une volonté de protéger son business, mais en aucun cas de proposer l’état de l’art au client. Faire du business ok, mais il faut avoir une éthique. Un mec comme [Schwaber](http://kenschwaber.wordpress.com/) me faire vomir tant il ne s’intéresse qu’au fric et je me bats contre [Scrum](http://www.scrumalliance.org/) car ce n’est qu’une marque.

Pour revenir au modèle, c’est je crois le défaut de tout modèle générique quel que soit sa qualité intrinsèque, il suffit de voir les dégâts de [CMMi](http://www.sei.cmu.edu/cmmi/) ou de [RUP](http://www-01.ibm.com/software/awdtools/rup/) par exemple. Il faut toujours se rappeler que la ruée vers l’or a surtout enrichi… les vendeurs de pioches.

Pour le Kanban que j’utilise depuis plus de 3 ans, c’est à la suite de l’échec rapide dans mon contexte du mode de management agile «traditionnel». La tactique que l’on utilise en agilité est de limiter le travail en segmentant la vie du projet en «itération», étape où l’équipe doit produire un logiciel fonctionnel. Cette itération est fixe, au niveau du temps comme du travail à produire, préalablement choisi avec le responsable projet à l’aide d’une métrique appelée vélocité. Un dashboard permet de visualiser l’avancée de l’itération. Je pense que tout le monde est maintenant familier avec tout cela, je n’irais donc pas plus loin.

J’ai commencé par une itération de 15 jours pour finir avec une itération de 5 jours, du déploiement continu et des phases de Q/A important lors des releases officielles (une par trimestre, mais on release chaque mois en interne). J’ai trouvé plusieurs lacunes graves à ce mode de management :

- la vélocité est une métrique boiteuse, sorte de moyenne des estimations des développeurs. Sans compter qu’on passait 1/8 de notre temps en planning poker.
- le dashboard n’est pas assez précis, il ne permet pas de comprendre finement le «système» (la R&D dans mon contexte).

Parallèlement je demandais depuis longtemps tant au responsable produit qu’au développeur de découper les tâches de plus en plus petites car je voulais une sortie rapide du système (un développement rapide), ce que le Lean appelle «cycle time». Et en modifiant petit à petit le management du projet pour combler les lacunes apparentes, je me suis rendu compte que la notion de flux était puissante. Je venais par petite touche de me rapprocher du Kanban. Depuis j’ai abandonné les estimations et les itérations pour une approche plus fine et souple avec une intégration des fonctionnalités quand elles sont prêtes (merci la gestion des branches des DVCS), des phases différentes selon qu’on release officiellement ou non (une release officielle demande des docs, une synchro avec le marketing et le commerce, etc), des «classes de service», c’est à dire des priorités différentes selon les demandes. Je modélise aussi bien les demandes fonctionnelles, de correction de bugs que de modification de l’infrastructure de création de doc. Je suis ravi de ces changements, je suis sorti d’un carcan pour créer une environnement adapté au business de la société. Entre temps, j’ai fait la relation avec mes lectures passées (le Lean et la théorie des contraintes) et découvert le Kanban, la plus proche émanation de la théorie des flux dans le contexte de développement logiciel. Bien que cela puisse paraître récent, c’est en fait assez vieux : la théorie des files d’attente du mathématicien Erlang, le travail du professeur du MIT [John Little](http://en.wikipedia.org/wiki/John_Little_%28academic%29), la théorie des contraintes, l’efficacité des batchs, on parle des années 1920 à 1970 ! On utilise ces théories dans beaucoup de domaines et Toyota l’a par exemple bien compris depuis longtemps. Après l’agilité, le Kanban représente pour moi une nouvelle avancée marquante dans le management de projet. Plus besoin de triturer son itération, et je rigole souvent quand j’entends les retours d’expérience de Scrumistes qui déforment leur pratique managériale pour faire tenir les demandes. Sans compter le puéril débat Scrum / [Scrumbut](http://www.scrum.org/scrumbut) qui ne fait que mettre en exergue le carcan qu’impose les soit disant experts. Dernier point, notre dashboard (un énorme tableau blanc avec des fiches cartonnées) permet de connaître à tout instant l’état exact du système, cela est très intéressant.

Voici un exemple que j’espère compréhensible : un jour, un des développeurs de l’équipe qui n’avait rien à faire prend une fiche de très basse priorité (les fiches importantes sont bloquées pour diverses raisons). Cela part d’un bon sentiment, il n’est pas payé à ne rien faire. Mais alors que la fiche semblait simple, cela à pris plus de temps que prévu. Pire la fiche a fait 2 aller/retour (la revue de code est obligatoire chez nous), elle a pris du temps à la R&D et une fiche plus prioritaire fut retardée. Du point de vue du développeur, il a occupé son temps à 100%, c’est donc positif. Mais du point de vue du système on est perdant, la fiche prioritaire est retardée. Une conséquence possible aurait pu être la non intégration de la fonctionnalité impactée pour la release du mois, ou pour la livraison d’un POC (test en avant vente) très important pour la société. Le Kanban a montré très facilement cela : on écrit la date quand on déplace de colonne la fiche (rappel, une colonne = un type de tâche), on peut ainsi voir le temps qu’elle a mis dans le système (temps du commencement du dev jusqu’à l’intégration dans la branche principale). On note aussi les aller / retour entre la colonne dev et la colonne revue. Il fut donc facile de constater que la fiche dite “facile” a passé 2 jours dans le système, avec 2 A/R. La fiche importante ayant du coup pris 1 jour de délais supplémentaire dans le système (alors qu’on avait prévu de finir assez facilement la veille). Si le développeur avait attendu au lieu de travailler, il aurait revue la fiche prioritaire 1h après et elle sortait rapidement. Autrement dit, il aurait mieux fallu qu’il glande au lieu de bosser ! Étonnant non ? Mais du point de vue du système, c’était la meilleure solution. Depuis, les développeurs n’ont plus honte d’utiliser le «slack time», temps où on ne peut rien faire et qu’on met a profit pour, par exemple, faire de la veille.

Il y a tant à dire sur le sujet que cela dépasse largement le cadre de cet interview. J’ai peur que beaucoup de lecteur se disent «encore un truc de manager» ou pire «c’est pour mettre encore plus de pression». Le meilleur moyen de faire baisser la pression et de travailler sereinement, c’est d’être efficace et sûrement pas de finir la mise en prod le vendredi à 22h ! Je suis devenu manager pour créer un environnement que le développeur que j’étais aurait aimé avoir, loin des environnements pourris qu’il a connu. Je vais bientôt proposer une conférence sur le sujet tellement je suis émerveillé. Mais la théorie des flux ne fait pas tout, cela rentre dans un cadre plus global de recherche de marché, d’analyse marketing produit, de gestion des hommes et de pratiques de développement logiciel. Je souris toujours quand je repense au geek qui ne pensait qu’a coder seul devant sa machine, mais tous ces domaines sont passionnants et surtout importants pour la réussite d’un projet. Développer un produit logiciel est fascinant.

**Agnès & Cédric: Comment se déroule l’une de tes journées types ? As-tu le temps de faire de la veille techno et de mettre les mains dans le code ? Ou es-tu maintenant plus passionné par l’agilité et le coaching ?**

**Sébastien**: Je fais environ une heure de veille par jour depuis que je travaille, ceux qui me suivent sur Twitter le croiront sans mal ![:)](http://jduchess.org/duchess-france/wp-includes/images/smilies/icon_smile.gif) . J’ai cumulé beaucoup de casquettes pendant longtemps : directeur technique, admin système & réseau, responsable R&D, coach agile, coach organisationnel, testeur, responsable projet, responsable support, responsable logistique (nous vendons logiciel + matériel), release manager, développeur. On a fini d’optimiser certains process assez lourds comme la logistique et j’ai délégué certaines tâches comme le support, je peux donc revenir plus vers du code commun avec les développeurs. Mais avec mon emploi du temps, il est impossible de travailler sur du besoin métier, qui exige de gros blocs de temps sans interruption (ce qui est rarement le cas d’un manager) et surtout de travailler de concert avec les autres développeurs. Je m’occupe donc plus de projets d’infrastructure comme développer des outils internes, revoir nos techniques de tests, refactorer les couches techniques, simplifier la configuration du serveur d’application, extraire le code métier du code technique, repackager le code… Bref, baisser la complexité générale et éliminer les points techniques qui posent problème.

Cela permet d’apprendre beaucoup car on touche à tout sauf malheureusement au code métier. La couche système est ma seule implication de bout en bout car je suis un peu plus expérimenté que les autres.

La semaine dernière par exemple, j’ai transformé notre guide utilisateur [OpenOffice](http://www.openoffice.org/) en document [Sphinx](http://sphinx.pocoo.org/) ce qui permet de publier en plusieurs formats dont le HTML afin de l’intégrer aux sondes et d’utiliser [Git](http://git-scm.com/) comme backend. Et je suis en train de me replonger dans Latex pour modifier le format PDF. J’ai modifié notre socle pour faire du support par clé modem 3G et ainsi aider nos avant ventes chez des clients un peu parano qui n’acceptent pas le VPN par Internet (ce qui m’a demandé de refaire un nouveau kernel Linux, de transformer un usbstorage en usbserial, et de configurer ppp). Et j’ai testé plusieurs logiciels car je dois revoir notre pratique de tests fonctionnels. Bref, Je suis bien loin du manager qui fait du Powerpoint. J’ai d’ailleurs horreur des outils bureautiques, mes pres. comme mes blogs ou les documents que je produis sont aux format _rst_ ou _Markdown_ ![:)](http://jduchess.org/duchess-france/wp-includes/images/smilies/icon_smile.gif) .

Si je dois faire l’exercice de l’ascenseur à un recruteur, je dirais : vous gérer le commerce, le marketing et les finances, je m’occupe du reste ! Avoir autant de casquettes n’est pas facile et j’ai même failli devenir schizo, mais cela à un avantage indéniable : la prise de décision est fort simple ![:)](http://jduchess.org/duchess-france/wp-includes/images/smilies/icon_smile.gif) . En gros je fais ce que je veux, c’est la raison pour laquelle 99% de ce que j’ai mis en place depuis 4 ans était nouveau pour moi : je trouve quelque chose d’intéressant, quelques heures ou jours après c’est mis en place et appliqué, car je n’ai pas à convaincre un client ou mon chef. Résultat, une courbe d’apprentissage exceptionnelle, j’ai appris ces 4 dernières années 100x plus qu’en 8 ans de SSII. Pire, je me suis aperçu que mon expérience était faible et que je ne savais vraiment pas grand chose (j’en sais un poil plus maintenant ![:)](http://jduchess.org/duchess-france/wp-includes/images/smilies/icon_smile.gif) . De plus, je trouve le métier d’éditeur logiciel est bien plus intéressant et passionnant que de travailler en SSII, le business model étant plus contraignant : vous ne gagnez de l’argent qu’une fois le produit fini, et encore si le client en veut ! L’efficacité est primordiale, surtout si vous êtes une startup avec peu d’argent.

**Agnès & Cédric: Fais-tu quand même un peu de Java (on te sait assidu au ParisJUG) ? Quel regard as-tu sur cette plateforme et cette communauté par rapport à Python ?**

**Sébastien**: Il y a beaucoup à dire, notamment sur ce que j’appelle le «prisme Java», c’est à dire la déformation que vous avez à force de vivre dans cet écosystème. Je déteste Java (je suis devenu admin en 2001 pour ne pas faire du Java ou du PHP, véridique !), et si j’avais la moindre velléité d’en faire quand je suis arrivé au ParisJUG, ils m’ont définitivement dégoûtés ![:)](http://jduchess.org/duchess-france/wp-includes/images/smilies/icon_smile.gif) . L’objectif initial était d’aller vers des communautés de développeurs pour m’enrichir d’autres regards et pratiques sur le développement, et je côtoie toujours beaucoup de communautés. La rencontre avec des Javaistes fut… comment dire… difficile. Le monde Java est assez fermé (avec des œillères bien solides), possédant sa propre novlangue. Je ne comprenais rien (et je ne comprends toujours pas grand chose) des Javaistes quand ils parlent ! De mon point de vue, il y a 3 soucis majeurs dans le monde Java :

1. Une culture fortement dominée par des entreprises commerciales et cela se ressent, tant du coté des fournisseurs de solutions que des prestataires. Sans compter que 80% des développeurs Java que je vois travaillent pour des grands comptes, c’est fortement structurant.
2. Je n’apprécie pas du tout le système de typage, avec l’extrème verbosité d’un typage explicite et des NullPointerException au runtime par exemple. De mon point de vue, Haskell, OCaml ou C# sont bien plus intéressants sur ce point si on est intéressé par le typage statique. Scala est sur ce point une avancée intéressante. D’où aussi l’utilisation presque obligatoire d’un IDE.
3. Un langage rustique par certains cotés, qui a mal évolué, avec des lacunes. Quand je vois qu’il faut attendre Java 7 pour avoir la gestion des contextes (le try-statement) la gestion de plusieurs exceptions à la fois ou une librairie I/O potable, je rêve un peu. On gardera un voile pudique sur des errements comme la gestion des classpath ![:)](http://jduchess.org/duchess-france/wp-includes/images/smilies/icon_smile.gif) . Alors que de l’autre coté, le manuel de référence fait plus de 800 pages ! Par comparaison, Python en fait 120.

Pour moi, c’est la JVM qui sauve Java. Je trouve le langage en lui même assez médiocre. Mais le pire est que je constate souvent qu’un développeur Java passe 70% de son temps à régler des problèmes Java et non des problèmes métiers, d’où le surnom que je vous donne : «Mario», et l’expert Java «Super Mario». La complexité moyenne d’un projet est absolument incroyable ! Le développeur Java passe son temps à câbler des librairies (qui pour la plupart comblent les errements du langage) et à faire fonctionner des frameworks ensemble, c’est ennuyeux à mourir. Je suis impressionné par le niveau de connaissance nécessaire pour mener à bien un projet. Malheureusement la grande majorité des informations que vous emmagasinez n’a aucun intérêt pour moi. La conséquence est que votre échelle de complexité est maintenant complètement biaisée, et ce que vous appelez simplicité est pour moi bien trop complexe. Pire, ma simplicité est suspecte pour un développeur Java ! J’ai halluciné de lire un jour le résultat d’un questionnaire qui montrait qu’un développeur passait 14% à 28% de son temps à… attendre que le serveur d’application se lance ! Ou qu’un développeur lambda écrivait tout autant de xml que de Java. Le besoin de productivité, le fameux «time to market», ne permet plus de dépenser autant d’argent pour des résultats aussi faibles.

Mais depuis 3 ans les choses changent : la déception du rachat par Oracle, les 5 ans pour avoir 8 fonctionnalités, l’arrivée de Clojure, Scala, Groovy et surtout la prise de pouvoir du monde Web, philosophiquement assez éloigné du monde Java ont changé la donne.

Mais la raison essentielle de ma présence aux 3ème mi-temps (celle ou l’on boit, tu ne me verras pas souvent aux confs), c’est de se confronter à d’autres opinions, d’autres regards, car il est important de ne pas se figer dans ses croyances, de permettre de réfléchir à son propre prisme, ses propres blocages, ses propres lacunes. Ma conférence sur les langages dynamiques est par exemple une conséquence d’une réflexion sur ma relation avec la programmation qui fait suite à des discussions au ParisJUG. Et puis discuter entre passionnés autour d’une bière, j’adore. Que l’on parle moto, mécanique, photo, programmation, coaching, organisation, méthodo, rencontrer des gens est vital pour moi, j’ai besoin des autres pour initier et enrichir ma réflexion. Je suis trop stupide pour penser seul dans mon coin, j’ai besoin d’input ![:)](http://jduchess.org/duchess-france/wp-includes/images/smilies/icon_smile.gif) .

Pour Python, c’est bien différent :

- d’abord par l’aspect communautaire, très proche du Libre, que l’on retrouve dans beaucoup de langages. Il n’a pas des annonces tous les 2 mois de la techno géniale X qui va révolutionner le monde, j’apprends les sorties car je suis… le flux RSS du serveur qui centralise les composants Python.
- C’est un langage accessible, raison de sa popularité en tant qu’outil de formation à l’algorithmie dans de nombreuses universités. L’abandon de Scheme par Python au MIT à fait grand bruit d’ailleurs (le livre Scheme utilisé depuis 30 ans est un best-seller).
- Une productivité assez impressionnante par son expressivité et des axiomes puissants, qui vous rend accro très vite. Il partage avec [Git](http://git-scm.com/) et Unix une conception orthogonale : il existe un petit nombre de concepts mais qui donne une belle puissance quand ils sont additionnés. De plus il est cohérent, vous n’avez pas à lire la doc toute les 5 min pour comprendre ce qui se passe. Je ne parle pas du [first class object](http://en.wikipedia.org/wiki/First-class_object), la facilité d’introspection, ou la grosse librairie standard.
- Le langage est développé par une petite équipe (bien qu’on doit atteindre les 100 développeurs maintenant) qui fait cela sur leurs temps libres, ils ne se battent pas pour imposer telle ou telle lib (suivez mon regard), mais veillent avant tout à une cohérence d’ensemble. Et de toute façon on a un dictateur bienveillant qui tranche régulièrement. Malgré la faible taille, Le projet est fortement structuré (un exemple : l’équivalent du JSR appelé PEP est utilisé depuis 2000) et un management solide qui me laisse de temps en temps un poil baba. Python 3 est un bel exemple, notamment si on le compare avec PHP 6 et Perl 6.
- Ensuite, j’apprécie fortement le codage par «Duck Typing», beaucoup moins contraignant que le typage statique en Java. Lisez un code Java et dites vous quelles sont les lignes qui sont utiles pour le métier. En Java, c’est assez consternant. En Python, vous êtes proche du pseudo-code, tout en gardant une forte lisibilité. Cela n’a pas que des avantages bien sûr (Haskell ou OCaml ont bien plus d’intérêt), mais associé à la simplicité et l’expressivité du langage, l’équilibre général du langage est très intéressant.
- La communauté est dynamique, compétente et accueillante. Que ce soit celle des utilisateurs ou des _core developers_. Il existe une liste de diffusion pour débuter en programmation, de tutorat pour devenir _core developer_ par exemple. Il existe beaucoup de projets impressionnants par leur maturité technique. On est loin de la communauté PHP avec ses logiciels phares codés avec les pieds.
- Et enfin le projet [PyPy](http://pypy.org/) (VM avec un JIT) est très prometteur. La version en cours de développement est presque 5x plus rapide que l’interpréteur de référence CPython et ce n’est pas fini. Il existe même des implémentations de PHP ou de Smalltak et des backends .NET et JVM. Ce projet va sûrement rendre Python encore bien plus attractif.

Mais comme je le répète souvent, chaque langage est une vision du développement, et tout est question d’équilibre entre facilité et contrainte. Le saint Graal que représente la fusion du bon coté des langages dynamiques (le fun) et du bon coté des langages statiques (la performance et la plus grande sécurité) n’est pas encore atteint malgré quelques tentatives comme OCaml. En ce moment je suis beaucoup le langage Go et j’attends une stabilisation du projet pour m’y remettre. Je suis déçu par Scala qui manque d’accessibilité tant dans la syntaxe que la sémantique. C’est un langage puissant mais trop «brute de fonderie». Je garde ma préférence à Python car non seulement je me sens très productif tout en gardant une qualité de code certaine, mais aussi parce que le plaisir de coder est largement présent. Et ça, c’est essentiel.

### **Merci Sébastien!**

**Les inscriptions pour la session de Sébastien au [Lyon JUG](http://www.lyonjug.org) le 20 juillet sont ouvertes! De plus nous vous proposons un coding dojo, pour vous fournir une initiation pratique et gratuite à [Git](http://git-scm.com/). Celui-ci sera animé par Sébastien Douche lui-même et se déroulera mercredi 21 septembre de 19h à 21h à l’Epitech et se limitera à 20 personnes. Le Lyon JUG offrira les pizzas ! Rendez-vous sur le site du [Lyon JUG](http://www.lyonjug.org/evenements/git).**
